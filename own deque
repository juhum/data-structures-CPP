//
// Created by ANDDD on 13.04.2022.
//

#pragma once

#include <iostream>

class Deque {
    int capacity;
    int *mem;
    int elements;

    int first;


public:

    Deque():                                                   // write the constructor for Queue which initializes:
            capacity(10),                                  // capacity to 10
            mem(new int[capacity]),                   // mem with a new array
            elements(0),                                   // elements with 0

            first(0)                                    // first with 0
    {}

    ~Deque(){                       // write a destructor for Queue
        delete [] mem;
    }



    Deque(const Deque &ori)     // write a copy constructor for Queue
    {
        capacity=ori.capacity;
        mem=ori.mem;
        elements=ori.elements;
        first=ori.first;

    }


    Deque &operator=(Deque cpy){    // write an assignment operator for Queue
        capacity=cpy.capacity;
        elements=cpy.elements;
        std::swap(mem,cpy.mem);
        return *this;
    }


    void push_back(int x) {
        if (capacity == elements) {
            int *tmp = new int[capacity * 2];// resize the array

            for(int i=0;i<capacity;i++){   // copy elements
                tmp[i]=mem[i];
            }

            delete [] mem;
            mem = tmp;
            capacity *=2;  // change capactiy

            first =0;   // change first


        }
        int insertion_location = (first + elements) % capacity;

        mem[insertion_location] = x;

        elements++;

    }

    void push_front(int x){
        if ( capacity==elements) {
            int *tmp = new int[capacity * 2];

            for(int i=0;i<capacity;i++){
                tmp[i]=mem[i];
            }

            delete [] mem;
            mem = tmp;
            capacity *=2;

            first =0;
        }

        elements++;

        int temp;
        for(int i=0;i<(capacity-1);i++){
            temp=mem[capacity-1];
            mem[capacity-1]=mem[i];
            mem[i]=temp;
        }

        mem[0] = x;

    }

    bool empty(){
        if(elements==0)
            return true;
        return false;
    }


    void pop_front() {        // warning: unsafe, make safe
        if(empty())
            throw std::runtime_error("pop_front() called on an empty stack");

        first = (first + 1) % capacity;
         elements-1;
    }

    void pop_back(){
        if(empty())
            throw std::runtime_error("pop_back() called on an empty stack");

        elements--;
    }

    int front() {
        if(empty())
            throw std::runtime_error("front called on an empty stack");

        return mem[first];
    }

    int back(){
        if(empty())
            throw std::runtime_error("back called on an empty stack");

        return mem[elements-1];
    }

    int &operator[](int x) {
        return mem[x];
    }

    int size(){
        return capacity;
    }


};
