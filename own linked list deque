#pragma once

#include <iostream>
#include <stdexcept>

struct Node {
    int value;
    Node *next;
    Node *prev;

    Node(int v):
            value(v),
            next(nullptr),
            prev(nullptr) {}
};

class Deque {
    Node *head;
    Node *tail;
public:
    // constructor
    Deque():
        head(nullptr),
        tail(nullptr)
    {};

    // write a copy constructor
    Deque(const Deque &ori):head(nullptr),tail(nullptr){
        Node *tmp = ori.head;
        while(tmp!= nullptr){
            push_back(tmp->value);
            tmp=tmp->next;
        }


    }

    // write an assignment operator
    Deque &operator=(Deque cpy) {
        std::swap(cpy.head, head);
        std::swap(cpy.tail,tail);
        return *this;
    }


    // write a destructor
   ~Deque(){
        while(!empty())
            pop_front();

    }

    int back() {
        if(tail == nullptr)
            throw std::runtime_error("back called on empty deque");

        return tail->value;
    }

    int front() {
        if(empty())
            throw std::runtime_error("front called on empty deque");

        return head->value;
    }

    void push_back(int x) {
        // fill the push_back method
        if(empty()){
            head = new Node(x);
            tail=head;

        }
        else {
            Node *tmp = new Node(x);
            tail->next = tmp;
            tmp->prev = tail;
            tail = tmp;
        }
    }

    void push_front(int x) {
        // fill the push_front method
        if(empty())
            throw std::runtime_error("push_front called on empty deque");
        else{
            Node *tmp = new Node(x);
            head->prev = tmp;
            tmp->next = head;
            head = tmp;
            }

    }

    void pop_back() {
        // fill the push_front method
        if(tail == nullptr)
            throw std::runtime_error("pop back called on empty deque");

        Node *tmp = tail;
        tail = tail->prev;
        delete tmp;


    }

    void pop_front() {
        // fill the push_front method
        if (empty()) {
            throw std::runtime_error("pop on an empty stack");
        }
        if (head == tail) {
            delete head;
            head = tail = nullptr;
        } else {
            head = head->next;
            delete head->prev;
            head->prev = nullptr;
        }
    }




    bool empty() const {
        return head == nullptr;
    }

};

